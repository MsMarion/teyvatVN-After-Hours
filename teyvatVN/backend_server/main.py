from fastapi import FastAPI, Request, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel
import os
import json

# custom libs
import generate_ai_calls
import utils
import auth

app = FastAPI()

# Allow frontend to access this backend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5137","https://updates-limitations-favors-effectively.trycloudflare.com", "*"],  # your React app
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Define where chapter data is stored
DATA_DIR = os.path.join(os.path.dirname(__file__), "data")

# Pydantic model for chapter data
class ChapterData(BaseModel):
    title: str
    characters: list[str]
    backgrounds: list[str]
    setting_narration: str
    segments: list[dict]


# Pydantic model for simplified generation request
class GenerateRequest(BaseModel):
    prompt: str
    username: str

# Pydantic model for auth
class AuthRequest(BaseModel):
    username: str
    password: str

# Helper: get path to output.json for a chapter
def get_chapter_path(username: str, chapter_id: str) -> str:
    folder = os.path.join(DATA_DIR, username, chapter_id)
    os.makedirs(folder, exist_ok=True)
    return os.path.join(folder, "output.json")

# --- AUTH ENDPOINTS ---

@app.post("/api/auth/register")
async def register(request: AuthRequest):
    if not request.username or not request.password:
        raise HTTPException(status_code=400, detail="Username and password required")
    
    success = auth.create_user(request.username, request.password)
    if not success:
        raise HTTPException(status_code=400, detail="User already exists")
    
    return {"status": "success", "message": "User created"}

@app.post("/api/auth/login")
async def login(request: AuthRequest):
    if not auth.authenticate_user(request.username, request.password):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    return {"status": "success", "username": request.username, "token": "dummy-token-for-mvp"}


# --- STORY ENDPOINTS ---

# API: Get chapter
@app.get("/api/chapter/{username}/{chapter_id}")
def get_chapter(username: str, chapter_id: str):
    # In a real app, we would validate the token here to ensure the requester is the user
    path = get_chapter_path(username, chapter_id)
    if not os.path.exists(path):
        return {"message": "Chapter not found", "data": None}
    with open(path, "r", encoding="utf-8") as f:
        return {"message": "Loaded", "data": json.load(f)}

# Create a new chapter or overwrite it
@app.post("/api/{username}/{chapter_id}")
async def save_chapter(username: str, chapter_id: str, request: Request):
    try:
        body = await request.json()
        prompt = body["prompt"]
        char1 = body["char1"]
        char2 = body["char2"]
        background = body["background"] 
    except KeyError as e:
        raise HTTPException(status_code=400, detail=f"Missing field: {e}")
    except Exception:
        print("there was a bad call ")
        raise HTTPException(status_code=400, detail="Invalid JSON")


    print(f"Prompt is {prompt}")
    print(f"char1 is {char1}")
    print(f"char2 is {char2}")
    print(f"background is is {background}")

    # build input json for the actual story to be generated:
    chapter_input = {
        "characters": [char1, char2],
        "start_setting": background if isinstance(background, str) else background.get("name", "Unknown"),
        "story_direction": prompt
    }
    
    # Generate the full story
    try:
        story_segments = generate_ai_calls.generate_story(chapter_input)
    except Exception as e:
        print(f"Generation failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

    # Construct the final output object
    final_output = {
        "title": "Generated Story",
        "characters": [char1, char2],
        "backgrounds": [background],
        "setting_narration": "Scene generated by AI.",
        "segments": story_segments
    }

    # Save to file
    path = get_chapter_path(username, chapter_id)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(final_output, f, indent=2, ensure_ascii=False)

    return {"status": "success", "path": f"{username}/{chapter_id}/output.json", "data": final_output}


# NEW: Simplified generation endpoint
@app.post("/api/generate")
async def generate_chapter(request: GenerateRequest):
    """
    Generate a new chapter from a simple prompt.
    Auto-increments chapter ID and uses simplified generation.
    """
    try:
        prompt = request.prompt
        username = request.username
        
        if not prompt or not prompt.strip():
            raise HTTPException(status_code=400, detail="Prompt cannot be empty")
        
        if not username or not username.strip():
            raise HTTPException(status_code=400, detail="Username cannot be empty")
            
        # Validate user exists
        if not auth.get_user(username):
             raise HTTPException(status_code=401, detail="User not found")
        
        # Get next chapter ID
        chapter_id = utils.get_next_chapter_id(username)
        print(f"Generating chapter {chapter_id} for user {username}")
        print(f"Prompt: {prompt}")
        
        # Generate the chapter using new simplified function
        chapter_data = generate_ai_calls.generate_chapter_from_prompt(prompt)
        
        # Save to file
        path = utils.get_chapter_path(username, chapter_id)
        with open(path, "w", encoding="utf-8") as f:
            json.dump(chapter_data, f, indent=2, ensure_ascii=False)
        
        print(f"Chapter saved to {path}")
        
        return {
            "status": "success",
            "chapter_id": chapter_id,
            "path": f"{username}/{chapter_id}/output.json",
            "data": chapter_data
        }
        
    except Exception as e:
        print(f"Generation failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# Mount the /data directory for direct file access
app.mount("/data", StaticFiles(directory=DATA_DIR), name="data")


# ---- MAIN ENTRY ----
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="127.0.0.1", port=4000, reload=True)
