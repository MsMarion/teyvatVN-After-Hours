from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.orm import Session
from pydantic import BaseModel
import os
import json

from app.core.database import get_db
from app.core import security
from app.services import ai_service, auth_service
from app.common import utils

router = APIRouter()

class GenerateRequest(BaseModel):
    prompt: str
    username: str
    api_key: str | None = None

@router.post("/api/{username}/{chapter_id}")
async def save_chapter(username: str, chapter_id: str, request: Request, db: Session = Depends(get_db)):
    try:
        body = await request.json()
        prompt = body["prompt"]
        char1 = body["char1"]
        char2 = body["char2"]
        background = body["background"] 
    except KeyError as e:
        raise HTTPException(status_code=400, detail=f"Missing field: {e}")
    except Exception:
        print("there was a bad call ")
        raise HTTPException(status_code=400, detail="Invalid JSON")

    print(f"Prompt is {prompt}")
    print(f"char1 is {char1}")
    print(f"char2 is {char2}")
    print(f"background is is {background}")

    chapter_input = {
        "characters": [char1, char2],
        "start_setting": background if isinstance(background, str) else background.get("name", "Unknown"),
        "story_direction": prompt
    }

    user = auth_service.get_user(db, username)
    api_key = security.decrypt_value(user.gemini_api_key) if user else None
    
    use_dev_key = os.getenv("USE_DEV_KEY", "false").lower() == "true"
    if not api_key and not use_dev_key:
        raise HTTPException(status_code=400, detail="Please configure your Gemini API Key in Settings.")
    
    try:
        story_segments = ai_service.generate_story(chapter_input, api_key=api_key)
    except Exception as e:
        print(f"Generation failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

    final_output = {
        "title": "Generated Story",
        "characters": [char1, char2],
        "backgrounds": [background],
        "setting_narration": "Scene generated by AI.",
        "segments": story_segments
    }

    path = utils.get_chapter_path(username, chapter_id)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(final_output, f, indent=2, ensure_ascii=False)

    return {"status": "success", "path": f"{username}/{chapter_id}/output.json", "data": final_output}

@router.post("/api/generate")
async def generate_chapter(request: GenerateRequest, db: Session = Depends(get_db)):
    """
    Generate a new chapter from a simple prompt.
    Auto-increments chapter ID and uses simplified generation.
    """
    try:
        prompt = request.prompt
        username = request.username
        
        if not prompt or not prompt.strip():
            raise HTTPException(status_code=400, detail="Prompt cannot be empty")
        
        if not username or not username.strip():
            raise HTTPException(status_code=400, detail="Username cannot be empty")
            
        chapter_id = utils.get_next_chapter_id(username)
        print(f"Generating chapter {chapter_id} for user {username}")
        print(f"Prompt: {prompt}")
        
        user = auth_service.get_user(db, username)
        api_key = security.decrypt_value(user.gemini_api_key) if user else None
        
        use_dev_key = os.getenv("USE_DEV_KEY", "false").lower() == "true"
        if not api_key and not use_dev_key:
            raise HTTPException(status_code=400, detail="Please configure your Gemini API Key in Settings.")
        
        chapter_data = ai_service.generate_chapter_from_prompt(prompt, api_key=api_key)
        
        path = utils.get_chapter_path(username, chapter_id)
        with open(path, "w", encoding="utf-8") as f:
            json.dump(chapter_data, f, indent=2, ensure_ascii=False)
        
        print(f"Chapter saved to {path}")
        
        return {
            "status": "success",
            "chapter_id": chapter_id,
            "path": f"{username}/{chapter_id}/output.json",
            "data": chapter_data
        }
        
    except Exception as e:
        print(f"Generation failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))
