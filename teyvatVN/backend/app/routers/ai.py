"""
AI Router (API Endpoints)

This file defines the "web addresses" (URLs) that the Frontend uses to generate stories.
It acts as the bridge between the user's prompt and our AI Service.

Key Endpoints:
1.  **POST /api/generate**: The main "Quick Start" endpoint. Takes a prompt, makes a chapter.
2.  **POST /api/{username}/{chapter_id}**: A more detailed endpoint for saving specific chapter configurations.
"""

from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.orm import Session
from pydantic import BaseModel
import os
import json

from app.core.database import get_db
from app.core import security
from app.services import ai_service, auth_service
from app.common import utils

router = APIRouter()

# --- Data Models ---
class GenerateRequest(BaseModel):
    prompt: str
    username: str
    api_key: str | None = None

# --- Endpoints ---

@router.post("/api/{username}/{chapter_id}")
async def save_chapter(username: str, chapter_id: str, request: Request, db: Session = Depends(get_db)):
    """
    Generate and save a story chapter based on detailed inputs.

    This endpoint takes character, background, and story direction inputs,
    generates a full story using the AI service, and saves it to a file.

    Args:
        username (str): The username of the user.
        chapter_id (str): The ID of the chapter to save.
        request (Request): The request object containing JSON body.
        db (Session): Database session.

    Returns:
        dict: Status and data of the generated chapter.

        
    Advanced Generation Endpoint.
    
    Used when the user provides specific details like:
    - Character 1 Name
    - Character 2 Name
    - Specific Background
    - Story Direction
    
    It calls the AI Service to generate the story and then saves it to a file.
    """
    try:
        body = await request.json()
        prompt = body["prompt"]
        char1 = body["char1"]
        char2 = body["char2"]
        background = body["background"] 
    except KeyError as e:
        raise HTTPException(status_code=400, detail=f"Missing field: {e}")
    except Exception:
        print("there was a bad call ")
        raise HTTPException(status_code=400, detail="Invalid JSON")

    print(f"Prompt is {prompt}")
    print(f"char1 is {char1}")
    print(f"char2 is {char2}")
    print(f"background is is {background}")

    # Prepare data for the AI
    chapter_input = {
        "characters": [char1, char2],
        "start_setting": background if isinstance(background, str) else background.get("name", "Unknown"),
        "story_direction": prompt
    }

    # Get the user's API key
    user = auth_service.get_user(db, username)
    api_key = security.decrypt_value(user.gemini_api_key) if user else None
    
    # Fallback to dev key if allowed
    use_dev_key = os.getenv("USE_DEV_KEY", "false").lower() == "true"
    if not api_key and not use_dev_key:
        raise HTTPException(status_code=400, detail="Please configure your Gemini API Key in Settings.")
    
    # Generate the story!
    try:
        story_segments = ai_service.generate_story(chapter_input, api_key=api_key)
    except Exception as e:
        print(f"Generation failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

    # Construct the final JSON structure
    final_output = {
        "title": "Generated Story",
        "characters": [char1, char2],
        "backgrounds": [background],
        "setting_narration": "Scene generated by AI.",
        "segments": story_segments
    }

    # Save to disk
    path = utils.get_chapter_path(username, chapter_id)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(final_output, f, indent=2, ensure_ascii=False)

    return {"status": "success", "path": f"{username}/{chapter_id}/output.json", "data": final_output}

@router.post("/api/generate")
async def generate_chapter(request: GenerateRequest, db: Session = Depends(get_db)):
    """
    Generate a new chapter from a simple prompt.
    
    This is a streamlined endpoint that auto-increments the chapter ID
    and uses a one-shot generation process.

    Args:
        request (GenerateRequest): The request body containing prompt and username.
        db (Session): Database session.

    Returns:
        dict: Status and data of the generated chapter.

        
    Quick Start Generation Endpoint.
    
    Used by the main "Prompt Input" page.
    1. Checks inputs.
    2. Finds the next available Chapter ID (e.g., "chapter_5").
    3. Calls the AI to generate the story.
    4. Saves the result.
    """
    try:
        prompt = request.prompt
        username = request.username
        
        if not prompt or not prompt.strip():
            raise HTTPException(status_code=400, detail="Prompt cannot be empty")
        
        if not username or not username.strip():
            raise HTTPException(status_code=400, detail="Username cannot be empty")
            
        # Auto-increment chapter ID
        chapter_id = utils.get_next_chapter_id(username)
        print(f"Generating chapter {chapter_id} for user {username}")
        print(f"Prompt: {prompt}")
        
        # Get API Key
        user = auth_service.get_user(db, username)
        api_key = security.decrypt_value(user.gemini_api_key) if user else None
        
        use_dev_key = os.getenv("USE_DEV_KEY", "false").lower() == "true"
        if not api_key and not use_dev_key:
            raise HTTPException(status_code=400, detail="Please configure your Gemini API Key in Settings.")
        
        # Generate!
        chapter_data = ai_service.generate_chapter_from_prompt(prompt, api_key=api_key)
        
        # Save!
        path = utils.get_chapter_path(username, chapter_id)
        with open(path, "w", encoding="utf-8") as f:
            json.dump(chapter_data, f, indent=2, ensure_ascii=False)
        
        print(f"Chapter saved to {path}")
        
        return {
            "status": "success",
            "chapter_id": chapter_id,
            "path": f"{username}/{chapter_id}/output.json",
            "data": chapter_data
        }
        
    except Exception as e:
        print(f"Generation failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))
